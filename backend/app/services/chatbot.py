# backend/app/services/chatbot.py
import logging
from typing import Optional
from app.models import Chatbot
from app.schemas.rag_config import RagConfigSchema, WidgetConfigSchema
from app.schemas import ChatbotCreate
from app.repositories.chatbot import ChatbotRepository

logger = logging.getLogger(__name__)


class ChatbotService:
    def __init__(self, repo: ChatbotRepository):
        """
        Initialize ChatbotService with repository.

        Args:
            repo: ChatbotRepository instance for database operations
        """
        self.repo = repo

    def _normalize_widget_config(self, widget_config: dict) -> dict:
        """Normalize widget_config from camelCase to snake_case."""
        normalized = {}
        for key, value in widget_config.items():
            if key == "primaryColor":
                normalized["primary_color"] = value
            elif key == "welcomeMessage":
                normalized["welcome_message"] = value
            else:
                normalized[key] = value
        return WidgetConfigSchema(**normalized).model_dump()

    def _normalize_rag_config(self, rag_config: dict) -> dict:
        """Validate and normalize rag_config using schema."""
        return RagConfigSchema(**rag_config).model_dump()

    def _apply_field_update(self, chatbot: Chatbot, field_name: str, value: any) -> None:
        """Apply a single field update with normalization if needed."""
        if field_name == "rag_config":
            setattr(chatbot, field_name, self._normalize_rag_config(value))
        elif field_name == "widget_config":
            setattr(chatbot, field_name, self._normalize_widget_config(value))
        else:
            setattr(chatbot, field_name, value)

    async def get_chatbot_by_id(self, chatbot_id: str) -> Optional[Chatbot]:
        """
        Get chatbot by internal ID.

        Args:
            chatbot_id: Chatbot UUID

        Returns:
            Chatbot instance if found

        Raises:
            ValueError: If chatbot not found
        """
        logger.debug(f"Fetching chatbot by id: {chatbot_id}")

        existing = await self.repo.get_with_tenant(chatbot_id)
        if existing:
            logger.debug(
                f"Chatbot found by id: {chatbot_id}, tenant_id: {existing.tenant_id}")
        else:
            logger.warning(f"Chatbot not found by id: {chatbot_id}")
            raise ValueError("Chatbot not found")

        return existing

    async def get_chatbot_by_public_id(self, public_id: str) -> Optional[Chatbot]:
        """
        Get chatbot by public ID (for widget usage).

        Args:
            public_id: Public-facing chatbot identifier

        Returns:
            Chatbot instance if found

        Raises:
            ValueError: If chatbot not found
        """
        logger.debug(f"Fetching chatbot by public_id: {public_id}")

        existing = await self.repo.get_by_public_id(public_id)
        if existing:
            logger.debug(
                f"Chatbot found by public_id: {public_id}, id: {existing.id}, tenant_id: {existing.tenant_id}")
        else:
            logger.warning(f"Chatbot not found by public_id: {public_id}")
            raise ValueError("Chatbot not found")
        return existing

    async def create_chatbot(self, data: ChatbotCreate) -> Chatbot:
        """
        Create a new chatbot from Pydantic schema.

        Args:
            data: Chatbot creation data

        Returns:
            Created chatbot instance
        """
        logger.info(
            f"Creating chatbot - name: {data.name}, tenant_id: {data.tenant_id}")

        # Normalize configs using helper methods
        rag_config_json = (
            self._normalize_rag_config(data.rag_config)
            if data.rag_config
            else RagConfigSchema().model_dump()
        )

        widget_config_json = (
            self._normalize_widget_config(data.widget_config)
            if data.widget_config
            else WidgetConfigSchema().model_dump()
        )

        new_bot = Chatbot(
            tenant_id=data.tenant_id,
            name=data.name,
            widget_config=widget_config_json,
            rag_config=rag_config_json,
            # public_id is auto-generated by Model default function
        )

        # Use repository to create chatbot
        created = await self.repo.create(new_bot)

        logger.info(
            f"Chatbot created successfully - id: {created.id}, public_id: {created.public_id}, tenant_id: {data.tenant_id}")
        return created

    async def list_for_tenant(self, tenant_id: str) -> list[Chatbot]:
        """
        List all chatbots for a tenant.

        Args:
            tenant_id: Tenant UUID

        Returns:
            List of chatbots
        """
        try:
            return await self.repo.list_for_tenant(tenant_id)
        except Exception:
            logger.error(
                f"Error listing chatbots for tenant: {tenant_id}", exc_info=True)
            return []

    async def update_chatbot(self, chatbot_id: str, **fields) -> Optional[Chatbot]:
        """
        Update chatbot settings (partial update).

        Args:
            chatbot_id: Chatbot UUID
            **fields: Fields to update (name, widget_config, rag_config, etc.)

        Returns:
            Updated chatbot instance or None if not found
        """
        chatbot = await self.get_chatbot_by_id(chatbot_id)
        if not chatbot:
            return None

        # Apply field updates using helper method
        for field_name, value in fields.items():
            if self._should_update_field(chatbot, field_name, value):
                self._apply_field_update(chatbot, field_name, value)

        return await self._commit_update(chatbot, chatbot_id)

    def _should_update_field(self, chatbot: Chatbot, field_name: str, value: any) -> bool:
        """Check if a field should be updated."""
        return hasattr(chatbot, field_name) and value is not None

    async def _commit_update(self, chatbot: Chatbot, chatbot_id: str) -> Optional[Chatbot]:
        """Commit chatbot update to database via repository."""
        try:
            updated = await self.repo.update(chatbot)
            logger.info(f"Chatbot updated - id: {chatbot.id}")
            return updated
        except Exception:
            logger.error(
                f"Error updating chatbot - id: {chatbot_id}", exc_info=True)
            return None

    async def delete_chatbot(self, chatbot_id: str) -> bool:
        """
        Delete a chatbot.

        Args:
            chatbot_id: Chatbot UUID

        Returns:
            True if deleted successfully
        """
        chatbot = await self.get_chatbot_by_id(chatbot_id)
        if not chatbot:
            return False
        try:
            await self.repo.delete(chatbot)
            logger.info(f"Chatbot deleted - id: {chatbot_id}")
            return True
        except Exception:
            logger.error(
                f"Error deleting chatbot - id: {chatbot_id}", exc_info=True)
            return False
